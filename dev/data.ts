import * as csv from 'csv-parse';
import * as commander from 'commander';
import * as fs from 'fs';
import * as path from 'path';
import { format } from 'prettier';
import * as glob from 'glob';
import { exec, ExecOptions } from 'child_process';

const read = (filename: string) =>
  new Promise((res, rej) => {
    fs.readFile(filename, (e, d) => (e ? rej(e) : res(d)));
  });

if (require.main === module) run().catch(console.error);

interface StateDataResult {
  State: string;
  'Percent in deserts - All': number;
  'Percent in deserts - Black': number;
  'Percent in deserts - White': number;
  'Percent in deserts - Hispanic': number;
  'Chidren under 5 in deserts- rural': number;
  'Children under 5 not in deserts- rural': number;
  'Children under 5 in deserts- suburban': number;
  'Children under 5 not in deserts- suburban': number;
  'Children under 5  in deserts- urban': number;
  'Children under 5 not in deserts- urban': number;
  'Text box': string;
}

function camelcase(p: string) {
  return p
    .split(/[^\w\d]+/i)
    .map(
      (s, i) =>
        i > 0
          ? s.charAt(0).toUpperCase() + s.slice(1, s.length).toLowerCase()
          : s.toLowerCase()
    )
    .join('');
}

async function run() {
  const program = commander
    .option('-s, --state-data <csvfile>', 'parse state data file')
    .option('-t, --tiles <glob>', 'generate mapbox tiles')
    .parse(process.argv);

  switch (true) {
    case !!program.stateData:
      await prepStateData(program.stateData);
      break;

    case !!program.tiles:
      await prepShapefiles(program.tiles);
      break;

    default: {
      program.outputHelp();
    }
  }

  process.exit(0);
}

async function prepShapefiles(globString: string) {
  const files = glob.sync(globString);
  const tmp = path.join(__dirname, '../data/tmp');
  if (!fs.existsSync(tmp)) fs.mkdirSync(tmp);

  await Promise.all(
    files.map(async file => {
      const bits = file.split('/');
      const name = bits[bits.length - 1].replace('.shp', '');
      await prun(`\`npm bin\`/shp2json -o ./data/tmp/${name}.json ${file}`);
      await prun(
        `tippecanoe -o ./data/tmp/${name}.mbtiles -Z 2 -zg ./data/tmp/${name}.json`
      );
      console.log(`Converted ${name}...`);
    })
  );

  console.log(`finished!`);
}

async function prepStateData(filename: string) {
  const file = await read(path.join(process.cwd(), filename));
  const result = await new Promise<StateDataResult[]>((res, rej) =>
    csv(
      file.toString(),
      { auto_parse: true, columns: true },
      (err: Error, d: any) => (err ? rej(err) : res(d))
    )
  );

  const states = result.map(r => r.State);
  const reduced = result.reduce((out, r: any) => {
    out[r.State] = Object.keys(r).reduce((d, k) => {
      d[camelcase(k)] = r[k];
      return d;
    }, {} as any);
    return out;
  }, {} as any);

  const code = format(
    `
/**
 *
 * don't edit this file, it's generated by ./dev/data.ts using the state csv file
 *
 */
/**
 * name of state with data
 */
      export type StateName = ${states.map(s => JSON.stringify(s)).join('|')};

      export const stateList: StateName[] = ${JSON.stringify(states)};

      export const stateData = ${JSON.stringify(reduced)};
    `,
    { singleQuote: true }
  );

  console.log(`writing ./src/data/states.ts...`);
  fs.writeFileSync(path.join(__dirname, '../src/data/states.ts'), code);
}

// promise based exec
export default function prun(
  cmd: string,
  options: ExecOptions = {}
): Promise<{ err: Error; stdout: string; stderr: string }> {
  // always resolve with err, standard out, and standard error
  const cb = (res: any) => (err: Error, stdout: string, stderr: string) => {
    res({ err, stdout, stderr });
  };
  return new Promise(res => {
    exec(cmd, options, cb(res));
  });
}
